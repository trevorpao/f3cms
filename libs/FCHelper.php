<?php

namespace F3CMS;

/**
 * Filecache handler
 */
class FCHelper extends Reaction
{
    /**
     * @var int
     */
    public $pause = false;

    /**
     * @var int
     */
    public $ifHistory = 0;
    /**
     * @var string
     */
    private $action = '';
    /**
     * @var string
     */
    private $path = '';
    /**
     * @var string
     */
    private $base = 'cache';

    /**
     * constructor
     *
     * @param object $dbInstance - db instance
     *
     * @return none
     */
    public function __construct($action)
    {
        $this->base = f3()->get('abspath') . $this->base;

        // Create the cache directory if it doesn't exist
        if (!file_exists($this->base)) {
            mkdir($this->base, 0770, true);
        }

        // Enable pause mode in debug mode
        if (f3()->get('DEBUG') > 1) {
            $this->pause = true;
        }

        $this->action = $action;
    }

    /**
     * Save content to cache
     *
     * @param string $cacheName The name of the cache
     * @param string $content   The content to be cached
     *
     * @return mixed
     */
    public function save($cacheName, $content)
    {
        $filename = $this->getFilename($cacheName);

        // Minify content and add cache metadata
        $content = self::minify($content) . PHP_EOL .
        '<!-- cache: ' . $cacheName . ' (generated at ' . date('y-m-d H:i:s') . ') DO NOT EDIT THIS FILE -->' . PHP_EOL . PHP_EOL;

        // If history logging is enabled, create a backup and log the change
        if ($this->ifHistory) {
            $bakname = $this->getBackupFilename();

            $this->writeFile($bakname, $content);

            $staff = f3()->get('SESSION.cs.name');

            $this->writeFile(
                $this->path . '/history.log',
                '|' . date('Y-m-d H:i:s') . PHP_EOL . '變動人：' . (($staff) ?: remote_ip()) . PHP_EOL . $bakname . PHP_EOL,
                'a+'
            );
        }

        // Write the content to the cache file
        $this->writeFile($filename, $content);

        return $content;
    }

    /**
     * Handle GET request
     *
     * @param object $f3   The F3 instance
     * @param array  $args The request arguments
     *
     * @return mixed
     */
    public function do_get($f3, $args)
    {
        $req = parent::_getReq();
        extract($req, EXTR_SKIP);

        // Determine the action based on the page
        switch ($page) {
            case 'press':
                $this->action = 'press';
                break;
            default:
                $this->action = 'page';
                break;
        }

        // Get the cached HTML content
        $html = $this->get($this->action, 7200);

        return parent::_return(1, ['html' => $html]);
    }

    /**
     * Flush cache files
     *
     * @param string $cacheName    The name of the cache to flush
     * @param bool   $useWildcard  Whether to use wildcard matching
     */
    public function flush($cacheName, $useWildcard = false)
    {
        $filename = $this->getFilename($cacheName);

        // If wildcard matching is enabled, adjust the filename
        if ($useWildcard) {
            $filename = str_replace('index.html', '', $filename);
        }

        // Remove the matching cache files
        $this->removeFiles($filename);
    }

    /**
     * Flush all cache files
     */
    public function flushAll()
    {
        $this->removeFiles('/' . $this->action . '/');
    }

    /**
     * Get cached content
     *
     * @param string $cacheName   The name of the cache
     * @param int    $maxLifetime The maximum lifetime of the cache in minutes
     *
     * @return mixed
     */
    public function get($cacheName, $maxLifetime = 0)
    {
        $filename = $this->getFilename($cacheName);

        // Check if the cache needs to be rebuilt
        if (0 != $maxLifetime && $this->needRebuild($filename, $maxLifetime)) {
            return null;
            // return $this->requestSet($cacheName);
        }

        // Load cache
        try {
            return $this->readCache($cacheName, $filename);
        } catch (\Exception $e) {
            return null;
        }
    }

    /**
     * Get cache change log
     *
     * @param string $cacheName The name of the cache
     *
     * @return array
     */
    public function getLog($cacheName)
    {
        $filename = $this->getFilename($cacheName);
        $content  = @file_get_contents($this->base . $this->path . '/history.log');

        if (false !== $content) {
            $rtn = preg_split("/\|/u", $content);

            return array_filter(array_map('trim', $rtn));
        } else {
            return '';
        }
    }

    /**
     * Request and set cache content
     *
     * @param string $cacheName The name of the cache
     *
     * @return mixed
     */
    public function requestSet($cacheName)
    {
        $curl = curl_init();

        curl_setopt_array($curl, [
            CURLOPT_URL            => f3()->get('uri') . '/' . $this->action,
            CURLOPT_RETURNTRANSFER => true,
            CURLOPT_SSL_VERIFYPEER => false,
            CURLOPT_SSL_VERIFYHOST => false,
            CURLOPT_ENCODING       => '',
            CURLOPT_MAXREDIRS      => 10,
            CURLOPT_TIMEOUT        => 30,
            CURLOPT_HTTP_VERSION   => CURL_HTTP_VERSION_1_1,
            CURLOPT_IPRESOLVE      => CURL_IPRESOLVE_V4,
            CURLOPT_CUSTOMREQUEST  => 'GET',
            CURLOPT_HTTPHEADER     => [
                'cache-control: no-cache',
            ],
        ]);

        $response = curl_exec($curl);
        $err      = curl_error($curl);

        curl_close($curl);

        if ($err) {
            return 'cURL Error #:' . $err;
        } else {
            return $this->set($this->action, $response, 60);
        }
    }

    /**
     * Write content to a file
     *
     * @param string $path    The file path
     * @param string $content The content to write
     * @param string $mode    The file mode (default: 'w+')
     */
    private function writeFile($path, $content, $mode = 'w+')
    {
        // Create the file if it doesn't exist
        if (!file_exists($this->base . $path)) {
            touch($this->base . $path);
        }

        $handler = fopen($this->base . $path, $mode);
        fwrite($handler, $content);
        fclose($handler);
    }

    /**
     * Returns cache filename.
     *
     * @param string $cacheName
     *
     * @return string
     */
    protected function getFilename($cacheName)
    {
        $this->path = '/' . $this->action . '/' . md5($cacheName . f3()->get('upload_dir'));

        // Create the directory for the cache file if it doesn't exist
        if (!file_exists($this->base . $this->path)) {
            mkdir($this->base . $this->path, 0770, true);
        }

        return $this->path . '/index.html';
    }

    /**
     * Returns cache filename.
     *
     * @return string
     */
    protected function getBackupFilename()
    {
        return $this->path . '/' . date('ymdHis') . '.html';
    }

    /**
     * Removes files matching given path.
     *
     * @param string $path
     */
    protected function removeFiles($path)
    {
        $path = $this->base . $path;

        if (is_dir($path)) {
            foreach (glob($path . '*') as $filename) {
                if (is_dir($filename)) {
                    array_map('unlink', glob($filename . '/*'));
                    @rmdir($filename);
                } else {
                    @unlink($filename);
                }
            }
        } else {
            @unlink($path);
        }
    }

    /**
     * Determines wheater the cache needs to be rebuild or not.
     *
     * @param string $filename
     * @param int    $maxLifetime
     *
     * @return bool
     */
    protected function needRebuild($filename, $maxLifetime)
    {
        if ($this->pause) {
            return true;
        }

        // cache does not exist
        if (!file_exists($this->base . $filename)) {
            return true;
        }

        // cache is empty
        if (!@filesize($this->base . $filename)) {
            return true;
        }

        // cache resource was marked as obsolete
        if (($mtime = filemtime($this->base . $filename)) <= 1) {
            return true;
        }

        // maxlifetime expired
        if ($maxLifetime > 0 && (time() - $mtime) > $maxLifetime * 60) {
            return true;
        }

        // do not rebuild cache
        return false;
    }

    /**
     * Loads the file of a cached resource.
     *
     * @param string $cacheName
     * @param string $filename
     *
     * @return mixed
     */
    protected function readCache($cacheName, $filename)
    {
        if (!file_exists($this->base . $filename)) {
            return '';
        }

        // get file content
        $content = file_get_contents($this->base . $filename);

        // find first newline
        $position = strpos($content, PHP_EOL);
        if (false === $position) {
            throw new \Exception('Unable to load cache resource "' . $cacheName . '"');
        }

        // cut content
        // $content = substr($content, $position + 1);

        return $content;
    }

    /**
     * Loads the file of a cached resource.
     *
     * @param string $filename
     *
     * @return mixed
     */
    public function readHistory($filename)
    {
        // get file contents
        $content = file_get_contents($this->base . $filename);

        // find first newline
        $position = strpos($content, PHP_EOL);
        if (false === $position) {
            throw new \Exception('Unable to load cache resource "' . $filename . '"');
        }

        return $content;
    }

    /**
     * Minify the given buffer
     *
     * @param string $buffer The content to minify
     *
     * @return mixed
     */
    public static function minify($buffer)
    {
        // return $buffer;

        $search = [
            '/\>[^\S ]+/s', // strip whitespaces after tags, except space
            '/[^\S ]+\</s', // strip whitespaces before tags, except space
            '/(\s)+/s', // shorten multiple whitespace sequences
        ];

        $replace = [
            '>',
            '<',
            '\\1',
        ];

        $buffer = preg_replace($search, $replace, $buffer);

        return $buffer;
    }
}
